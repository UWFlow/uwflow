CREATE TABLE course (
  id INT
    GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
  code TEXT NOT NULL
    CONSTRAINT course_code_unique UNIQUE
    CONSTRAINT course_code_length CHECK (LENGTH(code) <= 16),
  name TEXT NOT NULL
    CONSTRAINT course_name_length CHECK (LENGTH(name) <= 256),
  description TEXT
    CONSTRAINT course_description_length CHECK (LENGTH(name) <= 1024),
  textbooks JSONB,
  timeslots JSONB
);

CREATE TABLE course_antirequisite (
  course_id INT
    REFERENCES course(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  antirequisite_id INT
    REFERENCES course(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);

CREATE TABLE course_prerequisite (
  course_id INT
    REFERENCES course(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  prerequisite_id INT
    REFERENCES course(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  is_corequisite BOOLEAN NOT NULL
);

CREATE VIEW course_postrequisite AS
SELECT
  prerequisite_id AS course_id,
  course_id AS postrequisite_id,
  is_corequisite
FROM course_prerequisite;

CREATE TABLE prof (
  id INT
    GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
  name TEXT NOT NULL
    CONSTRAINT prof_name_length CHECK (LENGTH(name) <= 256)
);

CREATE TABLE "user" (
  id INT
    GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
  name TEXT NOT NULL
    CONSTRAINT user_name_length CHECK (LENGTH(name) <= 256),
  program TEXT
    CONSTRAINT user_program_length CHECK (LENGTH(program) <= 256)
);

CREATE TABLE course_review (
  id INT
    GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
  course_id INT
    REFERENCES course(id)
    ON UPDATE CASCADE ON DELETE SET NULL,
  prof_id INT
    REFERENCES prof(id)
    ON UPDATE CASCADE ON DELETE SET NULL,
  user_id INT
    REFERENCES "user"(id)
    ON UPDATE CASCADE ON DELETE SET NULL,
  text TEXT
    CONSTRAINT course_review_length CHECK (LENGTH(text) <= 8192),
  easy FLOAT
    CONSTRAINT easy_range CHECK (0 <= easy AND easy <= 1),
  liked FLOAT,
    CONSTRAINT liked_range CHECK (0 <= liked AND liked <= 1),
  useful FLOAT
    CONSTRAINT useful_range CHECK (0 <= useful AND useful <= 1)
);

CREATE TABLE prof_review (
  id INT
    GENERATED BY DEFAULT AS IDENTITY
    PRIMARY KEY,
  course_id INT
    REFERENCES course(id)
    ON UPDATE CASCADE ON DELETE SET NULL,
  prof_id INT
    REFERENCES prof(id)
    ON UPDATE CASCADE ON DELETE SET NULL,
  user_id INT
    REFERENCES "user"(id)
    ON UPDATE CASCADE ON DELETE SET NULL,
  text TEXT
    CONSTRAINT prof_review_length CHECK (LENGTH(text) <= 8192),
  clear BOOLEAN,
  engaging BOOLEAN
);

CREATE TABLE course_review_vote (
  review_id INT NOT NULL
    REFERENCES course_review(id)
    ON UPDATE CASCADE
    ON DELETE CASCADE,
  user_id INT NOT NULL
    REFERENCES "user"(id)
    ON UPDATE CASCADE
    ON DELETE CASCADE,
  vote INT NOT NULL
    CONSTRAINT vote_range CHECK (vote = -1 OR vote = 1),
  PRIMARY KEY(review_id, user_id)
);

CREATE TABLE prof_review_vote (
  review_id INT NOT NULL
    REFERENCES prof_review(id)
    ON UPDATE CASCADE
    ON DELETE CASCADE,
  user_id INT NOT NULL
    REFERENCES "user"(id)
    ON UPDATE CASCADE
    ON DELETE CASCADE,
  vote INT NOT NULL
    CONSTRAINT vote_range CHECK (vote = -1 OR vote = 1),
  PRIMARY KEY(review_id, user_id)
);

-- Aggregations intractable in Hasura
CREATE SCHEMA aggregate;

CREATE VIEW aggregate.course_review_buckets AS
SELECT
  course_id,
  SUM((easy < 0.2)::INT) AS easy_1q,
  SUM((0.2 <= easy AND easy < 0.4)::INT) AS easy_2q,
  SUM((0.4 <= easy AND easy < 0.6)::INT) AS easy_3q,
  SUM((0.6 <= easy AND easy < 0.8)::INT) AS easy_4q,
  SUM((0.8 <= easy)::INT) AS easy_5q,
  SUM((liked < 0.2)::INT) AS liked_1q,
  SUM((0.2 <= liked AND liked < 0.4)::INT) AS liked_2q,
  SUM((0.4 <= liked AND liked < 0.6)::INT) AS liked_3q,
  SUM((0.6 <= liked AND liked < 0.8)::INT) AS liked_4q,
  SUM((0.8 <= liked)::INT) AS liked_5q,
  SUM((useful < 0.2)::INT) AS useful_1q,
  SUM((0.2 <= useful AND useful < 0.4)::INT) AS useful_2q,
  SUM((0.4 <= useful AND useful < 0.6)::INT) AS useful_3q,
  SUM((0.6 <= useful AND useful < 0.8)::INT) AS useful_4q,
  SUM((0.8 <= useful)::INT) AS useful_5q
FROM course_review GROUP BY course_id;

CREATE VIEW aggregate.prof_review_stats AS
SELECT
  prof_id,
  SUM(CASE WHEN clear THEN 1 ELSE 0 END) AS clear,
  SUM(CASE WHEN NOT clear THEN 1 ELSE 0 END) AS not_clear,
  SUM(CASE WHEN engaging THEN 1 ELSE 0 END) AS engaging,
  SUM(CASE WHEN NOT engaging THEN 1 ELSE 0 END) AS not_engaging
FROM prof_review GROUP BY prof_id;

-- Credentials
CREATE SCHEMA secret;

CREATE TABLE secret.user_email (
  user_id INT
    REFERENCES "user"(id)
    ON UPDATE CASCADE
    ON DELETE CASCADE,
  email TEXT
    CONSTRAINT email_length CHECK (LENGTH(email) <= 256),
  password_hash TEXT
    CONSTRAINT password_hash_length CHECK (LENGTH(password_hash) = 60)
);
